/************************************************************************
*  File: plx_lib.c
*
*  Library for accessing PLX devices.
*  The code accesses hardware using WinDriver's WDC library.
*  Code was generated by DriverWizard v7.01.
*
*  Copyright (c) 2003 - 2005 Jungo Ltd.  http://www.jungo.com
*************************************************************************/
#define WD_DRIVER_NAME_CHANGE
#include <stdio.h>
#include <stdarg.h>
#include "wdc_defs.h"
#include "utils.h"
#include "status_strings.h"
#include "pci_regs.h"
#include "plx_lib_x.h"
#include "wdc_lib.h"
#include "windrvr.h"



/*************************************************************
  Internal definitions
 *************************************************************/
/* WinDriver license registration string */
/* TODO: When using a registered WinDriver version, replace the license string
         below with your specific WinDriver license registration string */
#define PLX_DEFAULT_LICENSE_STRING "6C3CC2AFA3140A1AF50563A6E11FF81482712B06.fuwch"
#define PLX_DEFAULT_DRIVER_NAME "windrvr6"

/* VPD EEPROM delay */
#define EEPROM_VPD_Delay() WDC_Sleep(20000, WDC_SLEEP_BUSY)

/* Run-time registers EEPROM delay */
#define EEPROM_RT_Delay() WDC_Sleep(500, WDC_SLEEP_BUSY)

/* Soft board reset delay */
#define PLX_SOFT_RESET_DELAY() WDC_Sleep(5000000, WDC_SLEEP_NON_BUSY)

typedef struct {
    WD_DMA *pDma;
    WD_DMA *pDmaList;
    PLX_DMA_CHANNEL dmaChannel;
    
    /* offsets of DMA registers */
    DWORD dwDMACSR;
    DWORD dwDMAMODE;
    DWORD dwDMAPADR;
    DWORD dwDMALADR;
    DWORD dwDMADPR;
    DWORD dwDMASIZ;

    /* physical address of the first descriptor in chain (used in chain mode) */
    UINT32 u32StartOfChain;

    /* abort mask */
    UINT32 u32AbortMask;
} PLX_DMA_STRUCT;

/* PLX device information struct */
typedef struct {
    WD_PCI_ID id;
    BOOL fIsMaster;

    WD_TRANSFER *pIntTransCmds;
    /* indices of registers inside the transfer commands */
    BYTE bIntCsrIndex;
    BYTE bDmaCsrIndex;

    PLX_INT_HANDLER funcDiagIntHandler;
    PLX_EVENT_HANDLER funcDiagEventHandler;

    PLX_DMA_STRUCT *pPLXDma; /* relevant only for master devices */

    /* offsets of some useful registers */
    DWORD dwINTCSR;
    DWORD dwCNTRL;
    DWORD dwPROT_AREA;
    DWORD dwLAS0BA;
    /* TODO: You can add fields to store additional device-specific information */
} PLX_DEV_CTX, *PPLX_DEV_CTX;

/* TODO: You can add fields to store additional device-specific information */
static inline BOOL IsValidDevice(PWDC_DEVICE pDev, const CHAR *sFunc)
{
    if (!pDev || !(PPLX_DEV_CTX)(pDev->pCtx))
    {
        return FALSE;
    }

    return TRUE;
}

BOOL bfBlock = FALSE;

static BOOL IsDeviceValid(const PWDC_DEVICE pDev);
static DWORD DeviceInit(PWDC_DEVICE pDev, BOOL fIsMaster);
static DWORD IntDisableDma(WDC_DEVICE_HANDLE hDev);

static DWORD EEPROM_VPD_EnableAccess(WDC_DEVICE_HANDLE hDev, UINT32 *pu32DataOld);
static DWORD EEPROM_VPD_RestoreAccess(WDC_DEVICE_HANDLE hDev, UINT32 u32Data);
static DWORD EEPROM_VPD_RemoveWriteProtection(WDC_DEVICE_HANDLE hDev, WORD wAddr, PBYTE pbDataOld);
static DWORD EEPROM_VPD_RestoreWriteProtection(WDC_DEVICE_HANDLE hDev, WORD wAddr);
static void EEPROM_RT_ChipSelect(WDC_DEVICE_HANDLE hDev, BOOL fSelect);
static void EEPROM_RT_ReadBit(WDC_DEVICE_HANDLE hDev, BOOL *pBit);
static void EEPROM_RT_WriteBit(WDC_DEVICE_HANDLE hDev, BOOL bit);
static void EEPROM_RT_WriteEnableDisable(WDC_DEVICE_HANDLE hDev, BOOL fEnable);

/*************************************************************
  Functions implementation
 *************************************************************/
/* -----------------------------------------------
    PLX and WDC library initialize/uninit
   ----------------------------------------------- */
/* -----------------------------------------------
    PLX and WDC library initialize/uninit
   ----------------------------------------------- */
DWORD PLX_LibInit(void)
{
    DWORD dwStatus;
    /* Set the driver name */
    if (!WD_DriverName(PLX_DEFAULT_DRIVER_NAME))
    {
//        ErrLog("Failed to set the driver name for WDC library.\n");
        return WD_SYSTEM_INTERNAL_ERROR;
    }
    /* Set WDC library's debug options (default: level TRACE, output to Debug Monitor) */
    dwStatus = WDC_SetDebugOptions(WDC_DBG_DEFAULT, NULL);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        return dwStatus;
    }

    /* Open a handle to the driver and initialize the WDC library */
    dwStatus = WDC_DriverOpen(WDC_DRV_OPEN_DEFAULT, PLX_DEFAULT_LICENSE_STRING);
    if (WD_STATUS_SUCCESS != dwStatus)
    {     
        return dwStatus;
    }

    return WD_STATUS_SUCCESS;
}

DWORD PLX_LibUninit(void)
{
    DWORD dwStatus;

    /* Uninit the WDC library and close the handle to WinDriver */
    dwStatus = WDC_DriverClose();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
		return 0;
    }

    return dwStatus;
}

_declspec (dllexport) DWORD PLX_DeviceOpenBySlot(WDC_DEVICE_HANDLE *pDeviceHandle, const WD_PCI_SLOT *pSlot, BOOL fIsMaster)
{
    DWORD dwStatus;    
    WD_PCI_CARD_INFO deviceInfo;
    PPLX_DEV_CTX pDevCtx = NULL;
    WDC_DEVICE_HANDLE hDev = NULL;

    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        return dwStatus;
    }

    /* NOTE: You can modify the device's resources information here, if
       necessary (mainly the deviceInfo.Card.Items array or the items number -
       deviceInfo.Card.dwItems) in order to register only some of the resources
       or register only a portion of a specific address space, for example. */

    /* Allocate memory for the PLX device context */
    pDevCtx = (PPLX_DEV_CTX)malloc(sizeof (PLX_DEV_CTX));
    if (!pDevCtx)
    {
        return WD_INSUFFICIENT_RESOURCES;
    }

    BZERO(*pDevCtx);

    /* Open a WDC device handle */
    dwStatus = WDC_PciDeviceOpen(&hDev, &deviceInfo, pDevCtx, NULL, NULL, NULL);

    if (WD_STATUS_SUCCESS != dwStatus)
    {
        goto Error;
    }

    *pDeviceHandle = hDev;

    /* Validate device information */
    if (!IsDeviceValid(hDev))
    {
        dwStatus = WD_INVALID_PARAMETER;
        goto Error;
    }

    /* Initialize device context and validate device information */
    dwStatus = DeviceInit(hDev, fIsMaster);
    if (dwStatus)
        goto Error;

    /* Return handle to the new device */
    return dwStatus;

Error:    
    if (hDev)
        PLX_DeviceClose(hDev);
    else
        free(pDevCtx);
    
    return dwStatus; 
}

static BOOL IsDeviceValid(const PWDC_DEVICE pDev)
{
    DWORD i, dwNumAddrSpaces = pDev->dwNumAddrSpaces;

    /* TODO: Modify the implementation of this function in order to verify
             that your device has all expected resources */
    
    /* Verify that the device has at least one active address space */
    for (i = 0; i < dwNumAddrSpaces; i++)
    {
        if (WDC_AddrSpaceIsActive(pDev, i))
            return TRUE;
    }
    
    return FALSE;
}

static DWORD DeviceInit(PWDC_DEVICE pDev, BOOL fIsMaster)
{
    PPLX_DEV_CTX pDevCtx = (PPLX_DEV_CTX)WDC_GetDevContext(pDev);
    
    /* NOTE: You can modify the implementation of this function in order to
             perform any additional device initialization you require */
    
    /* Set device type - master/target */
    pDevCtx->fIsMaster = fIsMaster;

    /* Set offsets for some registers */
    /* Offsets of DMA registers will be set in PLX_DMAOpen() */
    if (fIsMaster)
    {
        pDevCtx->dwINTCSR = PLX_M_INTCSR;
        pDevCtx->dwCNTRL = PLX_M_CNTRL;
        pDevCtx->dwPROT_AREA = PLX_M_PROT_AREA;
        pDevCtx->dwLAS0BA = PLX_M_LAS0BA;
    }
    else
    {
        pDevCtx->dwINTCSR = PLX_T_INTCSR;
        pDevCtx->dwCNTRL = PLX_T_CNTRL;
        pDevCtx->dwPROT_AREA = PLX_T_PROT_AREA;
        pDevCtx->dwLAS0BA = PLX_T_LAS0BA;
    }

    /* Enable target abort for master devices */
    if (fIsMaster)
    {
        UINT32 u32IntStatus = 0;
        
        PLX_ReadReg32(pDev, PLX_M_INTCSR, &u32IntStatus);
        PLX_WriteReg32(pDev, PLX_M_INTCSR, u32IntStatus | BIT12);
    }
    
    return WD_STATUS_SUCCESS;
}

_declspec (dllexport) BOOL PLX_DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    DWORD dwStatus;
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    PPLX_DEV_CTX pDevCtx;
   
    if (!hDev)
    {
        return FALSE;
    }

    pDevCtx = (PPLX_DEV_CTX)WDC_GetDevContext(pDev);
    
    /* Disable interrupts */
    if (WDC_IntIsEnabled(hDev))
    {
        dwStatus = PLX_IntDisable(hDev);
        if (WD_STATUS_SUCCESS != dwStatus)
        {
			return FALSE;
        }
    }

    /* Close the device */
    dwStatus = WDC_PciDeviceClose(hDev);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
		return FALSE;
    }

    /* Free PLX device context memory */
    if (pDevCtx)
        free (pDevCtx);
    
    return (WD_STATUS_SUCCESS == dwStatus);
}

_declspec (dllexport) DWORD PLX_IntDisable(WDC_DEVICE_HANDLE hDev)
{
    DWORD dwStatus;
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    PPLX_DEV_CTX pDevCtx;

    if (!IsValidDevice(pDev, "PLX_IntDisable"))
        return WD_INVALID_PARAMETER;

    pDevCtx = (PPLX_DEV_CTX)WDC_GetDevContext(hDev);
 
    if (!WDC_IntIsEnabled(hDev))
    {
        return WD_OPERATION_ALREADY_DONE;
    }

    /* Physically disable the interrupts on the board */
    dwStatus = ((PPLX_DEV_CTX)(pDev->pCtx))->fIsMaster ?
        IntDisableDma(hDev) : IntDisable(hDev);

    /* Disable the interrupts */
    dwStatus = WDC_IntDisable(hDev);
    if (WD_STATUS_SUCCESS != dwStatus)
    {

    }

    /* Free the memory allocated for the interrupt transfer commands */
    if (pDevCtx->pIntTransCmds)
    {
        free(pDevCtx->pIntTransCmds);
        pDevCtx->pIntTransCmds = NULL;
    }

    return dwStatus;
}
/* -----------------------------------------------
    DMA (Direct Memory Access)
   ----------------------------------------------- */
void PLX_DMAClose(WDC_DEVICE_HANDLE hDev, PLX_DMA_HANDLE hDma);

DWORD PLX_DMAOpen(WDC_DEVICE_HANDLE hDev, UINT32 u32LocalAddr, PVOID *ppBuf,
    DWORD dwOptions, DWORD dwBytes, WDC_ADDR_MODE mode,
    PLX_DMA_CHANNEL dmaChannel, PLX_DMA_HANDLE *ppDmaHandle)
{
    DWORD dwStatus;
    PPLX_DEV_CTX pDevCtx;
    UINT32 u32DMAMODE;
    BOOL fAutoinc = TRUE;
    PLX_DMA_STRUCT *pPLXDma = NULL;
    BOOL fSG = !(dwOptions & DMA_KERNEL_BUFFER_ALLOC);
    BOOL fIsRead = dwOptions & DMA_FROM_DEVICE ? TRUE : FALSE;
    
    if (!IsValidDevice((PWDC_DEVICE)hDev, "PLX_DMAOpen"))
        return WD_INVALID_PARAMETER;
    
    if (!ppBuf)
    {
        return WD_INVALID_PARAMETER;
    }

    pPLXDma = (PLX_DMA_STRUCT*)malloc(sizeof(PLX_DMA_STRUCT));
    if (!pPLXDma)
    {
        return WD_INSUFFICIENT_RESOURCES;
    }
    BZERO(*pPLXDma);
    
    /* Allocate and lock a DMA buffer */
    dwStatus = fSG ?
        WDC_DMASGBufLock(hDev, *ppBuf, dwOptions, dwBytes, &pPLXDma->pDma) :
        WDC_DMAContigBufLock(hDev, ppBuf, dwOptions, dwBytes, &pPLXDma->pDma);

    if (WD_STATUS_SUCCESS != dwStatus) 
    {
        goto Error;
    }

    pPLXDma->dmaChannel = dmaChannel;

    /* Set offsets of DMA registers */
    pPLXDma->dwDMACSR = (PLX_DMA_CHANNEL_0 == dmaChannel ? PLX_M_DMACSR0 : PLX_M_DMACSR1);
    pPLXDma->dwDMAMODE = (PLX_DMA_CHANNEL_0 == dmaChannel ? PLX_M_DMAMODE0 : PLX_M_DMAMODE1);
    pPLXDma->dwDMAPADR = (PLX_DMA_CHANNEL_0 == dmaChannel ? PLX_M_DMAPADR0 : PLX_M_DMAPADR1);
    pPLXDma->dwDMALADR = (PLX_DMA_CHANNEL_0 == dmaChannel ? PLX_M_DMALADR0 : PLX_M_DMALADR1);
    pPLXDma->dwDMADPR = (PLX_DMA_CHANNEL_0 == dmaChannel ? PLX_M_DMADPR0 : PLX_M_DMADPR1);
    pPLXDma->dwDMASIZ = (PLX_DMA_CHANNEL_0 == dmaChannel ? PLX_M_DMASIZ0 : PLX_M_DMASIZ1);
    pPLXDma->u32AbortMask = (PLX_DMA_CHANNEL_0 == dmaChannel ? BIT25 : BIT26);

    /* Common settings for chain and direct DMA */
    u32DMAMODE = 
        (fAutoinc ? 0 : BIT11) 
        | BIT6 /* Enable Ready input */
        | BIT8 /* Local burst */
        | ((WDC_MODE_8 == mode) ? 0 : (WDC_MODE_16 == mode) ? BIT0 : (BIT1 | BIT0));
    
    if (pPLXDma->pDma->dwPages == 1)
    {
        /* DMA of one page ==> direct DMA */
        PLX_WriteReg32(hDev, pPLXDma->dwDMAMODE, u32DMAMODE);
        PLX_WriteReg32(hDev, pPLXDma->dwDMAPADR, (UINT32)pPLXDma->pDma->Page[0].pPhysicalAddr);
        PLX_WriteReg32(hDev, pPLXDma->dwDMALADR, u32LocalAddr);
        PLX_WriteReg32(hDev, pPLXDma->dwDMASIZ, (UINT32)pPLXDma->pDma->Page[0].dwBytes);
        PLX_WriteReg32(hDev, pPLXDma->dwDMADPR, fIsRead ? BIT3 : 0);
    }
    else /* DMA of more then one page ==> chain DMA */
    {        
        typedef struct {
            UINT32 u32PADR;
            UINT32 u32LADR;
            UINT32 u32SIZ;
            UINT32 u32DPR;
        } DMA_LIST;
        
        DMA_LIST *pList = NULL;
        DWORD dwPageNumber;
        UINT32 u32StartOfChain, u32AlignShift, u32MemoryCopied;

        /* Allocate a kernel buffer to hold the chain of DMA descriptors
           includes extra 0x10 bytes for quadword alignment */
        dwStatus = WDC_DMAContigBufLock(hDev, (void *)&pList, DMA_TO_DEVICE,
            pPLXDma->pDma->dwPages * sizeof(DMA_LIST) + 0x10, &pPLXDma->pDmaList);
        if (WD_STATUS_SUCCESS != dwStatus)
        {
            goto Error;
        }

        /* Verification that bits 0-3 are zero (QUADWORD aligned) */
        u32AlignShift = 0x10 - ((UINT32)(unsigned long)pPLXDma->pDmaList->pUserAddr & 0xF);
        pList = (DMA_LIST*)((DWORD)pList + u32AlignShift);
        u32StartOfChain = (UINT32)pPLXDma->pDmaList->Page[0].pPhysicalAddr + u32AlignShift;
        pPLXDma->u32StartOfChain = u32StartOfChain;

        /* Setting chain of DMA pages in the memory */
        for (dwPageNumber = 0, u32MemoryCopied = 0;
            dwPageNumber < pPLXDma->pDma->dwPages;
            dwPageNumber++)
        {
            pList[dwPageNumber].u32PADR = 
                htod32((UINT32)pPLXDma->pDma->Page[dwPageNumber].pPhysicalAddr);
            pList[dwPageNumber].u32LADR = 
                htod32((u32LocalAddr + (fAutoinc ? u32MemoryCopied : 0)));
            pList[dwPageNumber].u32SIZ = 
                htod32((UINT32)pPLXDma->pDma->Page[dwPageNumber].dwBytes);
            pList[dwPageNumber].u32DPR = 
                htod32((u32StartOfChain + (UINT32)sizeof(DMA_LIST) * (dwPageNumber + 1))
                | BIT0 | (fIsRead ? BIT3 : 0));
            u32MemoryCopied += pPLXDma->pDma->Page[dwPageNumber].dwBytes;
        }
        
        pList[dwPageNumber - 1].u32DPR |= htod32(BIT1); /* Mark end of chain */
    
        PLX_WriteReg32(hDev, pPLXDma->dwDMAMODE, u32DMAMODE | BIT9); /* Chain transfer */
        PLX_WriteReg32(hDev, pPLXDma->dwDMADPR, u32StartOfChain | BIT0);

        /* flush the list of DMA descriptors from CPU cache to system memory */
        WDC_DMASyncCpu(pPLXDma->pDmaList);
    }

    *ppDmaHandle = (PLX_DMA_HANDLE)pPLXDma;

    /* update the device cntext */
    pDevCtx = (PPLX_DEV_CTX)WDC_GetDevContext(hDev);
    pDevCtx->pPLXDma = pPLXDma;
    
    return WD_STATUS_SUCCESS;

Error:
    if (pPLXDma)
        PLX_DMAClose(hDev, (PLX_DMA_HANDLE)pPLXDma);
    
    return dwStatus;
}

void PLX_DMAClose(WDC_DEVICE_HANDLE hDev, PLX_DMA_HANDLE hDma)
{
    DWORD dwStatus = WD_STATUS_SUCCESS;
    PLX_DMA_STRUCT *pPLXDma = (PLX_DMA_STRUCT*)hDma;
       
    if (!IsValidDevice((PWDC_DEVICE)hDev, "PLX_DMAClose"))
        return;
    
    if (!hDma)
    {
        return;
    }
    
    if (pPLXDma->pDma)
    {
        dwStatus = WDC_DMABufUnlock(pPLXDma->pDma);
        if (WD_STATUS_SUCCESS != dwStatus)
        {
        }
    }
    else
    {
    }
     
    if (pPLXDma->pDmaList)
    {
        dwStatus = WDC_DMABufUnlock(pPLXDma->pDmaList);
        if (WD_STATUS_SUCCESS != dwStatus)
        {
        }
    }

    free(pPLXDma);
}

void PLX_DMASyncCpu(PLX_DMA_HANDLE hDma)
{
    WDC_DMASyncCpu(((PLX_DMA_STRUCT*)hDma)->pDma);
}

void PLX_DMASyncIo(PLX_DMA_HANDLE hDma)
{
    WDC_DMASyncIo(((PLX_DMA_STRUCT*)hDma)->pDma);
}

void PLX_DMAStart(WDC_DEVICE_HANDLE hDev, PLX_DMA_HANDLE hDma)
{
    PLX_DMA_STRUCT *pPLXDma = (PLX_DMA_STRUCT*)hDma;
    
    PLX_DMASyncCpu(hDma);

    if (pPLXDma->pDmaList)
        PLX_WriteReg32(hDev, pPLXDma->dwDMADPR, pPLXDma->u32StartOfChain | BIT0);

    PLX_WriteReg8(hDev, pPLXDma->dwDMACSR, (BYTE)(BIT0 | BIT1));
}

BOOL PLX_DMAIsAborted(WDC_DEVICE_HANDLE hDev, PLX_DMA_HANDLE hDma)
{
    UINT32 intcsr, mask = ((PLX_DMA_STRUCT*)hDma)->u32AbortMask;

    PLX_ReadReg32(hDev, PLX_M_INTCSR, &intcsr);

    return ((intcsr & mask) != mask);
}

BOOL PLX_DMAIsDone(WDC_DEVICE_HANDLE hDev, PLX_DMA_HANDLE hDma)
{
    BYTE dmacsr = 0;

    PLX_ReadReg8(hDev, ((PLX_DMA_STRUCT*)hDma)->dwDMACSR, &dmacsr);
    
    return (dmacsr & (BYTE)BIT4) == (BYTE)BIT4;
}

BOOL PLX_DMAPollCompletion(WDC_DEVICE_HANDLE hDev, PLX_DMA_HANDLE hDma)
{
    while (!PLX_DMAIsDone(hDev, hDma) && !PLX_DMAIsAborted(hDev, hDma))
        ;

    PLX_DMASyncIo(hDma);
    return !PLX_DMAIsAborted(hDev, hDma);
}

_declspec (dllexport) void PLX_DIAG_DMAClose(WDC_DEVICE_HANDLE hDev, PLX_DIAG_DMA *pDma)
{
    DWORD dwStatus;

    if (!pDma)
        return;
    
    if (PLX_IntIsEnabled(hDev))
    {
        dwStatus = PLX_IntDisable(hDev);
        printf("DMA interrupts disable%s\n",
            (WD_STATUS_SUCCESS == dwStatus) ? "d" : " failed");
    }

    if (pDma->hDma)
    {
        PLX_DMAClose(hDev, pDma->hDma);
        printf("DMA closed (handle 0x%p)\n", pDma->hDma);
    }
    
    if (pDma->fSG && pDma->pBuf)
            free(pDma->pBuf);

    BZERO(*pDma);
}

/* *pdwOptions = (1 == tmp) ? DMA_FROM_DEVICE : DMA_TO_DEVICE; */

_declspec (dllexport) void PLX_DIAG_DMAOpen(WDC_DEVICE_HANDLE hDev, 
					  PLX_DIAG_DMA *pDma, 
					  PLX_DMA_CHANNEL dmaChannel,
					  DWORD dwBytes,
					  DWORD dwOptions,
					  BOOL fSG)
{
    DWORD dwStatus;
    UINT32 u32LocalAddr = 0x16800;
    WDC_ADDR_MODE mode = WDC_MODE_32; /* Local bus width */
    
    /* Allocate buffer for Scatter/Gather DMA (if selected) */
  if (pDma->fSG) 
    {
        pDma->pBuf = malloc(dwBytes);

        if (!pDma->pBuf)
        {
            return;
        }
        memset(pDma->pBuf, 0, dwBytes);
    }

    /* Open DMA for selected channel */
    dwStatus = PLX_DMAOpen(hDev, u32LocalAddr, &pDma->pBuf, dwOptions,
        dwBytes, mode, dmaChannel, &pDma->hDma);

    if (WD_STATUS_SUCCESS == dwStatus)
    {
        printf("DMA for channel %d opened successfully (handle 0x%p)\n",
            dmaChannel, pDma->hDma);
    }
    else
    {
        printf("Failed to open DMA for channel %d. Error 0x%lx - %s\n",
            dmaChannel, dwStatus, Stat2Str(dwStatus));
        goto Error;
    }

    /* Start DMA */
    PLX_DMAStart(hDev, pDma->hDma);

Error:
    printf("Started DMA on channel %d\n", dmaChannel);
    

	
}

static DWORD IntDisableDma(WDC_DEVICE_HANDLE hDev)
{
    UINT32 u32INTCSR = 0, u32DMAMODE = 0;

    PLX_ReadReg32(hDev, PLX_M_INTCSR, &u32INTCSR);
    PLX_WriteReg32(hDev, PLX_M_INTCSR,
        u32INTCSR & ~(BIT8 | BIT18 | BIT19));

    PLX_ReadReg32(hDev, PLX_M_DMAMODE0, &u32DMAMODE);
    PLX_WriteReg32(hDev, PLX_M_DMAMODE0, u32DMAMODE & ~BIT10);

    PLX_ReadReg32(hDev, PLX_M_DMAMODE1, &u32DMAMODE);
    PLX_WriteReg32(hDev, PLX_M_DMAMODE1, u32DMAMODE & ~BIT10);
    
    return WD_STATUS_SUCCESS;
}

_declspec (dllexport) DWORD IntDisable(WDC_DEVICE_HANDLE hDev)
{
    WORD wINTCSR = 0;
	WORD wValue;

    PLX_ReadReg16(hDev, PLX_T_INTCSR, &wINTCSR);
//  PLX_WriteReg16(hDev, PLX_T_INTCSR, (WORD)(wINTCSR & ~(BIT8 | BIT10)));
	wValue = (WORD)(wINTCSR & ~(BIT8 | BIT10));
	WDC_DIAG_ReadWriteAddr(hDev, WDC_WRITE, 0, 0x68, &wValue, WDC_MODE_16);

    return WD_STATUS_SUCCESS;
}

_declspec (dllexport) DWORD P9054_IntEnable(WDC_DEVICE_HANDLE hDev)
{
    WORD wINTCSR = 0;
	WORD wValue = 0x8900;

    PLX_ReadReg16(hDev, PLX_T_INTCSR, &wINTCSR);
//  PLX_WriteReg16(hDev, PLX_T_INTCSR, 0x8900);

	WDC_DIAG_ReadWriteAddr(hDev, WDC_WRITE, 0, 0x68, &wValue, WDC_MODE_16);
//	WDC_DIAG_ReadWriteAddr(hDev, WDC_WRITE, 2, 0x0, &chint, WDC_MODE_8);
//	P9054_WriteByte(hPlx, BAR3, 0x2,0x0); //打开LINT

    return WD_STATUS_SUCCESS;
}

_declspec (dllexport) BOOL PLX_IntIsEnabled(WDC_DEVICE_HANDLE hDev)
{
    if (!IsValidDevice((PWDC_DEVICE)hDev, "PLX_IntIsEnabled"))
        return FALSE;

    return WDC_IntIsEnabled(hDev);
}

/* mask for all PLX interrupts */
#define PLX_MASTER_INT_MASK ((UINT32) (\
        BIT5    /* power management */ \
        | BIT13 /* PCI Doorbell */ \
        | BIT14 /* PCI Abort */ \
        | BIT15 /* Local Input */ \
        | BIT20 /* Local Doorbell */ \
        | BIT21 /* DMA Channel 0 */ \
        | BIT22 /* DMA Channel 1 */ \
        | BIT23 /* BIST */ \
        ))

#define PLX_TARGET_INT_MASK ((WORD) (\
    BIT2    /* LINTi1 Status */ \
    | BIT5  /* LINTi2 Status */ \
    ))

//static void DLLCALLCONV PLX_IntHandler(PVOID pData);

DWORD IntEnable(PWDC_DEVICE pDev, INT_HANDLER funcDiagIntHandler)
{
    DWORD dwStatus;
    PPLX_DEV_CTX pDevCtx = (PPLX_DEV_CTX)WDC_GetDevContext(pDev);
    WORD wINTCSR = 0;
       
    
    /* Read the value of the INTCSR register */
    dwStatus = PLX_ReadReg16(pDev, pDevCtx->dwINTCSR, &wINTCSR);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        goto Error;
    }
    
	dwStatus = WDC_IntEnable(pDev, 0, 0,
        0, funcDiagIntHandler, (PVOID)pDev, FALSE);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
		goto Error;
    }

    /* Physically enable the interrupts on the board, Windriver原生错误，屏蔽之后就能使能中断
	
    dwStatus = PLX_WriteReg16(pDev, pDevCtx->dwINTCSR, (WORD)(wINTCSR | BIT8 | BIT10));    
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        goto Error;
    }
   */

    return WD_STATUS_SUCCESS;
    
Error:

    return dwStatus;
}
/*
static void DLLCALLCONV PLX_IntHandler(PVOID pData)
{
    /* TODO: Modify the interrupt handler code to suit your specific needs
    
    PWDC_DEVICE pDev = (PWDC_DEVICE)pData;
    PPLX_DEV_CTX pDevCtx = (PPLX_DEV_CTX)WDC_GetDevContext(pDev);
    PLX_INT_RESULT intResult;

    BZERO(intResult);
    intResult.u32INTCSR = pDevCtx->pIntTransCmds[pDevCtx->bIntCsrIndex].Data.Word;
    intResult.dwCounter = pDev->Int.dwCounter;
    intResult.dwLost = pDev->Int.dwLost;
    intResult.waitResult = (WD_INTERRUPT_WAIT_RESULT)pDev->Int.fStopped;
    
    /* Execute the diagnostics application's interrupt handler routine
    pDevCtx->funcDiagIntHandler(pDev, &intResult);
}
*/
_declspec (dllexport) DWORD PLX_IntEnable(WDC_DEVICE_HANDLE hDev, INT_HANDLER funcDiagIntHandler)
{
    DWORD dwStatus;
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;

    if (!IsValidDevice(pDev, "PLX_IntEnable"))
        return WD_INVALID_PARAMETER;

    if (WDC_IntIsEnabled(hDev))
    {
        return WD_OPERATION_ALREADY_DONE;
    }
    
    dwStatus = IntEnable(pDev, funcDiagIntHandler);

    return dwStatus;
}

/* Read/write a memory or I/O address */
_declspec (dllexport) void WDC_DIAG_ReadWriteAddr(WDC_DEVICE_HANDLE hDev, WDC_DIRECTION direction,
    DWORD dwAddrSpace, DWORD dwOffset, PVOID pData, WDC_ADDR_MODE mode)
{
    DWORD dwStatus;

    if (!hDev)
    {
        return;
    }
    
    switch (mode)
    {
    case WDC_MODE_8:
        dwStatus = (WDC_READ == direction) ?
            WDC_ReadAddr8(hDev, dwAddrSpace, dwOffset, (BYTE *)pData) :
            WDC_WriteAddr8(hDev, dwAddrSpace, dwOffset, *((BYTE *)pData));
        break;
    case WDC_MODE_16:
        dwStatus = (WDC_READ == direction) ?
            WDC_ReadAddr16(hDev, dwAddrSpace, dwOffset, (WORD *)pData) :
            WDC_WriteAddr16(hDev, dwAddrSpace, dwOffset, *((WORD *)pData));
        break;
    case WDC_MODE_32:
        dwStatus = (WDC_READ == direction) ?
            WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, (UINT32 *)pData) :
            WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, *((UINT32 *)pData));
        break;
    case WDC_MODE_64:
        dwStatus = (WDC_READ == direction) ?
            WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, (UINT64 *)pData) :
            WDC_WriteAddr64(hDev, dwAddrSpace, dwOffset, *((UINT64 *)pData));
        break;
    default:
        return;
    }
}

_declspec (dllexport) BOOL PLX_GetAddrSpaceInfo(WDC_DEVICE_HANDLE hDev, PLX_ADDR_SPACE_INFO *pAddrSpaceInfo)
{
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    WDC_ADDR_DESC *pAddrDesc;
    DWORD dwAddrSpace, dwMaxAddrSpace;
    BOOL fIsMemory;
    
    if (!IsValidDevice(pDev, "PLX_GetAddrSpaceInfo"))
        return FALSE;

    dwAddrSpace = pAddrSpaceInfo->dwAddrSpace;
    dwMaxAddrSpace = pDev->dwNumAddrSpaces - 1;

    if (dwAddrSpace > dwMaxAddrSpace)
    {
        return FALSE;
    }

    pAddrDesc = &pDev->pAddrDesc[dwAddrSpace];

    fIsMemory = WDC_ADDR_IS_MEM(pAddrDesc);
    
    snprintf(pAddrSpaceInfo->sName, MAX_NAME - 1, "BAR %ld", dwAddrSpace);
    snprintf(pAddrSpaceInfo->sType, MAX_TYPE - 1, fIsMemory ? "Memory" : "I/O");
        
    if (WDC_AddrSpaceIsActive(pDev, dwAddrSpace))
    {
        WD_ITEMS *pItem = &pDev->cardReg.Card.Item[pAddrDesc->dwItemIndex];
        DWORD dwAddr = fIsMemory ? pItem->I.Mem.dwPhysicalAddr : (DWORD)pItem->I.IO.dwAddr;
        
        snprintf(pAddrSpaceInfo->sDesc, MAX_DESC - 1, "0x%0*lX - 0x%0*lX (%ld bytes)",
            (int)WDC_SIZE_32 * 2, dwAddr,
            (int)WDC_SIZE_32 * 2, dwAddr + pAddrDesc->dwBytes - 1,
            pAddrDesc->dwBytes);
    }
    else
        snprintf(pAddrSpaceInfo->sDesc, MAX_DESC - 1, "Inactive address space");

    return TRUE;
}

_declspec (dllexport) void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PLX_ADDR addrSpace)
{
    if (!WDC_AddrSpaceIsActive(hDev, addrSpace))
    {
        return;
    }
}

/* -----------------------------------------------
    Address spaces information
   ----------------------------------------------- */
_declspec (dllexport) DWORD PLX_GetNumAddrSpaces(WDC_DEVICE_HANDLE hDev)
{
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    
    if (!IsValidDevice(pDev, "PLX_GetNumAddrSpaces"))
        return 0;

    return pDev->dwNumAddrSpaces;
}

_declspec (dllexport) void WDC_DIAG_ReadWriteReg(WDC_DEVICE_HANDLE hDev, const WDC_REG *pRegs,
    DWORD dwNumRegs, PVOID pData, WDC_DIRECTION direction, BOOL fPciCfg)
{
    DWORD dwStatus;
    const WDC_REG *pReg; 
    BYTE bData = 0;
    WORD wData = 0;
    UINT32 u32Data = 0;
    UINT64 u64Data = 0;
    
    if (!hDev) return;
    if (!dwNumRegs || !pRegs) return;

    pReg = &pRegs[dwNumRegs];

    switch (pReg->dwSize)
    {
    case WDC_SIZE_8:
		bData = *((BYTE *)pData);
        if (WDC_READ == direction)
            dwStatus = fPciCfg ? WDC_PciReadCfg8(hDev, pReg->dwOffset, &bData) :
                WDC_ReadAddr8(hDev, pReg->dwAddrSpace, pReg->dwOffset, &bData);
        else
            dwStatus = fPciCfg ? WDC_PciWriteCfg8(hDev, pReg->dwOffset, bData) :
                WDC_WriteAddr8(hDev, pReg->dwAddrSpace, pReg->dwOffset, bData);
        break;
    case WDC_SIZE_16:
		wData = *((WORD *)pData);
        if (WDC_READ == direction)
            dwStatus = fPciCfg ? WDC_PciReadCfg16(hDev, pReg->dwOffset, &wData) :
                WDC_ReadAddr16(hDev, pReg->dwAddrSpace, pReg->dwOffset, &wData);
        else
            dwStatus = fPciCfg ? WDC_PciWriteCfg16(hDev, pReg->dwOffset, wData) :
                WDC_WriteAddr16(hDev, pReg->dwAddrSpace, pReg->dwOffset, wData);
        break;
    case WDC_SIZE_32:
		u32Data = *((UINT32 *)pData);
        if (WDC_READ == direction)
            dwStatus = fPciCfg ? WDC_PciReadCfg32(hDev, pReg->dwOffset, &u32Data) :
                WDC_ReadAddr32(hDev, pReg->dwAddrSpace, pReg->dwOffset, &u32Data);
        else
            dwStatus = fPciCfg ? WDC_PciWriteCfg32(hDev, pReg->dwOffset, u32Data) :
                WDC_WriteAddr32(hDev, pReg->dwAddrSpace, pReg->dwOffset, u32Data);
        break;
    case WDC_SIZE_64:
		u64Data = *((UINT64 *)pData);
        if (WDC_READ == direction)
            dwStatus = fPciCfg ? WDC_PciReadCfg64(hDev, pReg->dwOffset, &u64Data) :
                WDC_ReadAddr64(hDev, pReg->dwAddrSpace, pReg->dwOffset, &u64Data);
        else
            dwStatus = fPciCfg ? WDC_PciWriteCfg64(hDev, pReg->dwOffset, u64Data) :
                WDC_WriteAddr64(hDev, pReg->dwAddrSpace, pReg->dwOffset, u64Data);
        break;
    default:
        return;
    }
}

/* -----------------------------------------------
    Reset of PLX board
   ----------------------------------------------- */
/* Definition of abort bits in commad (CMD) configuration register */
#define PLX_M_CR_ABORT_BITS (\
    BIT24   /* Detected Master Data Parity Error */ \
    | BIT27 /* Signaled Target Abort */ \
    | BIT28 /* Received Target Abort */ \
    | BIT29 /* Received Master Abort */ \
    | BIT30 /* Signaled System Error */ \
    | BIT31 /* Detected Parity Error on PCI bus */ \
    )

/* Software board reset for master devices (9054, 9056, 9080, 9656) */
_declspec (dllexport) void PLX_SoftResetMaster(WDC_DEVICE_HANDLE hDev)
{
    BOOL fMUEnabled, fEEPROMPresent;
    WORD wCMD = 0;
    UINT32 u32QSR = 0;
    UINT32 u32CNTRL = 0;
    UINT32 u32INTLN = 0;
    UINT32 u32MBOX0 = 0, u32MBOX1 = 0;
    UINT32 u32HS_CNTL = 0;
    UINT32 u32PMCSR = 0;
    
    /* Clear any PCI errors */
    WDC_PciReadCfg16(hDev, PCI_CR, &wCMD);
    if (wCMD & PLX_M_CR_ABORT_BITS)
    {
        /* Write value back to clear aborts */
        WDC_PciWriteCfg16(hDev, PCI_CR, wCMD);
    }

    /* Save state of I2O Decode Enable */
    PLX_ReadReg32(hDev, PLX_M_QSR, &u32QSR);
    fMUEnabled = u32QSR & BIT0 ? TRUE : FALSE;

    /* Make sure S/W Reset & EEPROM reload bits are clear */
    PLX_ReadReg32(hDev, PLX_M_CNTRL, &u32CNTRL);
    u32CNTRL &= ~(BIT30 | BIT29);

    /* Determine if an EEPROM is present */
    fEEPROMPresent = PLX_EEPROMIsPresent(hDev);

    /* Save some registers if EEPROM present */
    if (fEEPROMPresent)
    {
        /* Run-time registers */
        PLX_ReadReg32(hDev, PLX_M_MBOX0, &u32MBOX0);
        PLX_ReadReg32(hDev, PLX_M_MBOX1, &u32MBOX1);

        /* PCI configuration registers */       
        WDC_PciReadCfg32(hDev, PCI_ILR, &u32INTLN);
        WDC_PciReadCfg32(hDev, PLX_HS_CAPID, &u32HS_CNTL);
        WDC_PciReadCfg32(hDev, PLX_PMCSR, &u32PMCSR);
    }

    /* Issue Software Reset to hold PLX chip in reset */
    PLX_WriteReg32(hDev, PLX_M_CNTRL, u32CNTRL | BIT30);

    /* Bring chip out of reset */
    PLX_SOFT_RESET_DELAY();
    PLX_WriteReg32(hDev, PLX_M_CNTRL, u32CNTRL);

    /* Issue EEPROM reload in case now programmed */
    PLX_WriteReg32(hDev, PLX_M_CNTRL, u32CNTRL | BIT29);

    /* Clear EEPROM reload */
    PLX_SOFT_RESET_DELAY();
    PLX_WriteReg32(hDev, PLX_M_CNTRL, u32CNTRL);

    /* Restore I2O Decode Enable state */
    if (fMUEnabled)
    {
        PLX_ReadReg32(hDev, PLX_M_QSR, &u32QSR);
        PLX_WriteReg32(hDev, PLX_M_QSR, u32QSR | BIT0);
    }

    /* If EEPROM was present, restore registers */
    if (fEEPROMPresent)
    {
        /* Run-time registers */
        PLX_WriteReg32(hDev, PLX_M_MBOX0, u32MBOX0);
        PLX_WriteReg32(hDev, PLX_M_MBOX1, u32MBOX1);

        /* PCI configuration registers */
        WDC_PciReadCfg32(hDev, PCI_ILR, &u32INTLN);

        /* Mask out HS bits that can be cleared */
        u32HS_CNTL &= ~(BIT23 | BIT22 | BIT17);
        WDC_PciWriteCfg32(hDev, PLX_HS_CAPID, u32HS_CNTL);

        /* Mask out PM bits that can be cleared */
        u32PMCSR &= ~BIT15;
        WDC_PciWriteCfg32(hDev, PLX_PMCSR, u32PMCSR);
    }
}

/* -----------------------------------------------
    Access the serial EEPROM
   ----------------------------------------------- */
BOOL PLX_EEPROMIsPresent(WDC_DEVICE_HANDLE hDev)
{
    PPLX_DEV_CTX pDevCtx = (PPLX_DEV_CTX)WDC_GetDevContext(hDev);
    UINT32 u32CNTRL = 0;
    
    PLX_ReadReg32(hDev, pDevCtx->dwCNTRL, &u32CNTRL);
    return (u32CNTRL & BIT28) == BIT28;
}

/* VPD EEPROM access */
BOOL PLX_EEPROM_VPD_Validate(WDC_DEVICE_HANDLE hDev)
{
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    BYTE bData = 0;

    if (!IsValidDevice(pDev, "PLX_EEPROM_VPD_Validate"))
        return FALSE;
    
    /* Verify that a blank or programmed serial EEPROM is present */
    if (!PLX_EEPROMIsPresent(hDev))
    {
        return FALSE;
    }
        
    /* Check the next capability pointers */
    WDC_PciReadCfg8(hDev, PCI_CAP, &bData);
    if (bData != (BYTE)PLX_PMCAPID)
    {
        return FALSE;
    }

    WDC_PciReadCfg8(hDev, PLX_PMNEXT, &bData);
    if (bData != (BYTE)PLX_HS_CAPID)
    {
        return FALSE;
    }

    WDC_PciReadCfg8(hDev, PLX_HS_NEXT, &bData);
    if (bData != (BYTE)PLX_VPD_CAPID)
    {
        return FALSE;
    }

    WDC_PciReadCfg8(hDev, PLX_VPD_NEXT, &bData);
    if (bData != 0)
    {
        return FALSE;
    }

    return TRUE;
}

DWORD PLX_EEPROM_VPD_Read32(WDC_DEVICE_HANDLE hDev, DWORD dwOffset, UINT32 *pu32Data)
{
    DWORD i;
    UINT32 u32EnableAccess;
    WORD wAddr, wData;

    if (!IsValidDevice((PWDC_DEVICE)hDev, "PLX_EEPROM_VPD_Read32"))
        return WD_INVALID_PARAMETER;

    if (dwOffset % 4)
    {
        return WD_INVALID_PARAMETER;
    }

    /* Clear EEDO Input Enable */
    EEPROM_VPD_EnableAccess(hDev, &u32EnableAccess);

    /* Write a destination serial EEPROM address and flag of operation, value of 0 */
    wAddr = (WORD)(dwOffset & ~BIT15);
    WDC_PciWriteCfg16(hDev, PLX_VPD_ADDR, wAddr);

    /* Probe a flag of operation until it changes to a 1 to ensure the Read data is available */
    for (i = 0; i < 10; i++)
    {
        EEPROM_VPD_Delay();
        WDC_PciReadCfg16(hDev, PLX_VPD_ADDR, &wData);
        
        if (wData & BIT15)
            break;
    }
    
    if (i == 10)
    {
        return WD_OPERATION_FAILED;
    }

    /* Read back the requested data from PVPDATA register */
    WDC_PciReadCfg32(hDev, PLX_VPD_DATA, pu32Data);

    /* Restore EEDO Input Enable */
    EEPROM_VPD_RestoreAccess(hDev, u32EnableAccess);
    
    return WD_STATUS_SUCCESS;
}

static DWORD EEPROM_VPD_EnableAccess(WDC_DEVICE_HANDLE hDev, UINT32 *pu32DataOld)
{
    DWORD dwCNTRL = ((PPLX_DEV_CTX)(((PWDC_DEVICE)hDev)->pCtx))->dwCNTRL;
    
    PLX_ReadReg32(hDev, dwCNTRL, pu32DataOld);
    return PLX_WriteReg32(hDev, dwCNTRL, *pu32DataOld & ~BIT31);
}

/* Restore EEDO Input Enable */
static DWORD EEPROM_VPD_RestoreAccess(WDC_DEVICE_HANDLE hDev, UINT32 u32Data)
{
    return PLX_WriteReg32(hDev, ((PPLX_DEV_CTX)((((PWDC_DEVICE)hDev)->pCtx)))->dwCNTRL,
        u32Data);
}

DWORD PLX_EEPROM_VPD_Write32(WDC_DEVICE_HANDLE hDev, DWORD dwOffset,
    UINT32 u32Data)
{
    DWORD i;
    UINT32 u32ReadBack, u32EnableAccess;
    WORD wAddr, wData;
    BYTE bEnableOffset;

    if (!IsValidDevice((PWDC_DEVICE)hDev, "PLX_EEPROM_VPD_Write32"))
        return WD_INVALID_PARAMETER;

    if (dwOffset % 4)
    {
        return WD_INVALID_PARAMETER;
    }
    
    /* Clear EEDO Input Enable */
    EEPROM_VPD_EnableAccess(hDev, &u32EnableAccess);

    wAddr = (WORD)dwOffset;
    EEPROM_VPD_RemoveWriteProtection(hDev, wAddr, &bEnableOffset);

    EEPROM_VPD_Delay();

    /* Write desired data to PVPDATA register */
    WDC_PciWriteCfg32(hDev, PLX_VPD_DATA, u32Data);

    /* Write a destination serial EEPROM address and flag of operation, value of 1 */
    wAddr = (WORD)(wAddr | BIT15);
    WDC_PciWriteCfg16(hDev, PLX_VPD_ADDR, wAddr);

    /* Probe a flag of operation until it changes to a 0 to ensure the write completes */
    for (i = 0; i < 10; i++)
    {
        EEPROM_VPD_Delay();
        WDC_PciReadCfg16(hDev, PLX_VPD_ADDR, &wData);
        if (wData & BIT15)
            break;
    }

    EEPROM_VPD_RestoreWriteProtection((PWDC_DEVICE)hDev, bEnableOffset);

    /* Restore EEDO Input Enable */
    EEPROM_VPD_RestoreAccess(hDev, u32EnableAccess);

    PLX_EEPROM_VPD_Read32(hDev, dwOffset, &u32ReadBack);
  
    if (u32ReadBack != u32Data)
    {
        return WD_OPERATION_FAILED;
    }

    return WD_STATUS_SUCCESS;
}

static DWORD EEPROM_VPD_RemoveWriteProtection(WDC_DEVICE_HANDLE hDev, WORD wAddr,
    PBYTE pbDataOld)
{
    PPLX_DEV_CTX pDevCtx = (PPLX_DEV_CTX)WDC_GetDevContext(hDev);

    PLX_ReadReg8(hDev, pDevCtx->dwPROT_AREA, pbDataOld);
    
    wAddr /= 4;
    wAddr &= 0x7F;

    PLX_WriteReg8(hDev, pDevCtx->dwPROT_AREA, (BYTE)wAddr);

    *pbDataOld *= 4; /* Expand from DWORD to BYTE count */

    return WD_STATUS_SUCCESS;
}

static DWORD EEPROM_VPD_RestoreWriteProtection(WDC_DEVICE_HANDLE hDev, WORD wAddr)
{    
    PPLX_DEV_CTX pDevCtx = (PPLX_DEV_CTX)WDC_GetDevContext(hDev);
    return PLX_WriteReg8(hDev, pDevCtx->dwPROT_AREA, (BYTE)wAddr);
}

DWORD PLX_EEPROM_RT_Read32(WDC_DEVICE_HANDLE hDev, DWORD dwOffset,
    UINT32 *pu32Data, DWORD EEPROMmsb)
{
    WORD wData1, wData2;
    
    if (!IsValidDevice((PWDC_DEVICE)hDev, "PLX_EEPROM_RT_Read32"))
        return WD_INVALID_PARAMETER;

    if (dwOffset % 4)
    {
        return WD_INVALID_PARAMETER;
    }
    
    PLX_EEPROM_RT_Read16(hDev, dwOffset, &wData1, EEPROMmsb);

    PLX_EEPROM_RT_Read16(hDev, dwOffset + 2, &wData2, EEPROMmsb);

    *pu32Data = (UINT32)((wData1 << 16) + wData2);
    
    return WD_STATUS_SUCCESS;
}

DWORD PLX_EEPROM_RT_Read16(WDC_DEVICE_HANDLE hDev, DWORD dwOffset, PWORD pwData,
    DWORD EEPROMmsb)
{
    WORD i;
    DWORD dwAddr = dwOffset >> 1;
    BOOL bit = 0;
    
    if (!IsValidDevice((PWDC_DEVICE)hDev, "PLX_EEPROM_RT_Read16"))
        return WD_INVALID_PARAMETER;

    *pwData = 0;

    EEPROM_RT_ChipSelect(hDev, TRUE);
    EEPROM_RT_WriteBit(hDev, 1);
    EEPROM_RT_WriteBit(hDev, 1);
    EEPROM_RT_WriteBit(hDev, 0);

    /* CS06, CS46 EEPROM - send 6bit address
     * CS56, CS66 EEPROM - send 8bit address */
    for (i = (WORD)EEPROMmsb; i; i >>= 1)
        EEPROM_RT_WriteBit(hDev, (dwAddr & i) == i);
    
    for (i = BIT15; i; i >>= 1)
    {
        EEPROM_RT_ReadBit(hDev, &bit);
        *pwData |= (bit ? i : 0);
    }

    EEPROM_RT_ChipSelect(hDev, FALSE);

    return WD_STATUS_SUCCESS;
}

static void EEPROM_RT_ChipSelect(WDC_DEVICE_HANDLE hDev, BOOL fSelect)
{
    DWORD dwCNTRL = ((PPLX_DEV_CTX)(((PWDC_DEVICE)hDev)->pCtx))->dwCNTRL;
    UINT32 u32CNTRL;

    PLX_ReadReg32(hDev, dwCNTRL, &u32CNTRL);
    
    PLX_WriteReg32(hDev, dwCNTRL,
        fSelect ? (u32CNTRL | BIT25) : (u32CNTRL & ~BIT25) );
    
    EEPROM_RT_Delay();
}

static void EEPROM_RT_ReadBit(WDC_DEVICE_HANDLE hDev, BOOL *pBit)
{
    DWORD dwCNTRL = ((PPLX_DEV_CTX)(((PWDC_DEVICE)hDev)->pCtx))->dwCNTRL;
    UINT32 u32CNTRL;

    PLX_ReadReg32(hDev, dwCNTRL, &u32CNTRL);

    /* clock */
    PLX_WriteReg32(hDev, dwCNTRL, u32CNTRL & ~BIT24);

    EEPROM_RT_Delay();

    PLX_WriteReg32(hDev, dwCNTRL, u32CNTRL | BIT24);

    EEPROM_RT_Delay();

    PLX_WriteReg32(hDev, dwCNTRL, u32CNTRL & ~BIT24);

    EEPROM_RT_Delay();

    /* data */
    PLX_ReadReg32(hDev, dwCNTRL, &u32CNTRL);
    *pBit = (u32CNTRL & BIT27) == BIT27;
}

static void EEPROM_RT_WriteBit(WDC_DEVICE_HANDLE hDev, BOOL bit)
{
    DWORD dwCNTRL = ((PPLX_DEV_CTX)(((PWDC_DEVICE)hDev)->pCtx))->dwCNTRL;
    UINT32 u32CNTRL;
    
    PLX_ReadReg32(hDev, dwCNTRL, &u32CNTRL);
    
    if (bit) /* data */
        u32CNTRL |= BIT26;
    else
        u32CNTRL &= ~BIT26;

    /* clock */
    PLX_WriteReg32(hDev, dwCNTRL, u32CNTRL & ~BIT24);

    EEPROM_RT_Delay();

    PLX_WriteReg32(hDev, dwCNTRL, u32CNTRL | BIT24);

    EEPROM_RT_Delay();

    PLX_WriteReg32(hDev, dwCNTRL, u32CNTRL & ~BIT24);

    EEPROM_RT_Delay();
}

static void EEPROM_RT_WriteEnableDisable(WDC_DEVICE_HANDLE hDev, BOOL fEnable)
{
    EEPROM_RT_ChipSelect(hDev, TRUE);

    /* Send a WEN instruction */
    EEPROM_RT_WriteBit(hDev, 1);
    EEPROM_RT_WriteBit(hDev, 0);
    EEPROM_RT_WriteBit(hDev, 0);
    EEPROM_RT_WriteBit(hDev, fEnable ? 1 : 0);
    EEPROM_RT_WriteBit(hDev, fEnable ? 1 : 0);

    EEPROM_RT_WriteBit(hDev, 0);
    EEPROM_RT_WriteBit(hDev, 0);
    EEPROM_RT_WriteBit(hDev, 0);
    EEPROM_RT_WriteBit(hDev, 0);

    EEPROM_RT_ChipSelect(hDev, FALSE);
}

_declspec (dllexport) void PLX_EEPROM_Read(WDC_DEVICE_HANDLE hDev, DWORD dwOffset, PVOID pData)
{
	UINT32 uData;
	DWORD dwStatus;
	BOOL fVPDSupported = PLX_EEPROM_VPD_Validate(hDev);

	uData = *((UINT32 *)pData);
	dwStatus = fVPDSupported ? PLX_EEPROM_VPD_Read32(hDev, dwOffset, &uData) : 
	PLX_EEPROM_RT_Read32(hDev, dwOffset, &uData, BIT7);
}

/* Find a PLX device */
_declspec (dllexport) BOOL PLX_DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WDC_PCI_SCAN_RESULT *pscanResult)
{
    DWORD dwStatus;
    DWORD dwNumDevices;

    if (dwVendorId == 0) 
	{
		return FALSE;
	}

    BZERO(*pscanResult);
    dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, pscanResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        return FALSE;
    }

    dwNumDevices = pscanResult->dwNumDevices;
    if (!dwNumDevices)
    {
        return FALSE;
    }

    return TRUE;
}

_declspec (dllexport) DWORD ReadProbeStatus(WDC_DEVICE_HANDLE hDev, DWORD dwProbeType)
{
	DWORD dwResult;

	switch(dwProbeType)
	{
	case PROBE_1:
			WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, 0, 0, &dwResult, WDC_MODE_32);
			return dwResult;
	case PROBE_2:
			WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, 0, 4, &dwResult, WDC_MODE_32);
			return dwResult;
	case PROBE_3:
			WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, 0, 8, &dwResult, WDC_MODE_32);
			return dwResult;
	case PROBE_4:
			WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, 0, 12, &dwResult, WDC_MODE_32);
			return dwResult;
	case PROBE_5:
			WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, 0, 16, &dwResult, WDC_MODE_32);
			return dwResult;
	case PROBE_6:
			WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, 0, 20, &dwResult, WDC_MODE_32);
			return dwResult;
	case PROBE_7:
			WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, 0, 24, &dwResult, WDC_MODE_32);
			return dwResult;
	case PROBE_8:
			WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, 0, 30, &dwResult, WDC_MODE_32);
			return dwResult;
	}
	return -1;
}

_declspec (dllexport) DWORD ReadRate(WDC_DEVICE_HANDLE hDev, DWORD dwRateType)
{


	DWORD dwResult;
	switch(dwRateType)
	{
	case RATE_TYPE_WIDTH:
		WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, 0, 34, &dwResult, WDC_MODE_32);
		return dwResult;
	case RATE_TYPE_LENGTH:
		WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, 0, 38, &dwResult, WDC_MODE_32);
		return dwResult;
	}
	return -1;
}

_declspec (dllexport) void SelectClock(WDC_DEVICE_HANDLE hDev, WORD dwValue)
{
	WDC_DIAG_ReadWriteAddr(hDev, WDC_WRITE, 2, CLOCK_OFFSET, &dwValue, WDC_MODE_16);
}

_declspec (dllexport) void SwitchChannel(WDC_DEVICE_HANDLE hDev, DWORD channelNo)
{
	WORD dwValue;
	dwValue = ( (char)(channelNo/ CHANNEL_CARD_NO ) <<8) + (channelNo % CHANNEL_SOFT);
	WDC_DIAG_ReadWriteAddr(hDev, WDC_WRITE, 2, CHANNEL_OFFSET, &dwValue, WDC_MODE_16);
}	

_declspec (dllexport) void PSUTMonitorDataRead(WDC_DEVICE_HANDLE hDev,void * pData)
{
	/***************************************************************************************/
	/***************************************** READ DATA VIA HPI *************************/
	WORD *p = (WORD *)pData;
	/* single read*/
	int nReadTime = MONITOR_DATA_SIZE/4;
	int i;
	
	for (i=0;i<nReadTime;i++)
	{
		WORD wValueL	=	(MONITOR_CHANNEL_2_BASE+i*PSUTHW_BUSWIDTH*2) & MONITOR_CHANNEL_ADDR_MASK;
		WORD wValueH	=	(MONITOR_CHANNEL_2_BASE+i*PSUTHW_BUSWIDTH*2) >> MONITOR_CHANNEL_ADDR_SHF;
		WDC_DIAG_ReadWriteAddr(hDev, WDC_WRITE, BAR2, HPI_RA_ADDR_L, &wValueL, WDC_MODE_16);
		WDC_DIAG_ReadWriteAddr(hDev, WDC_WRITE, BAR2, HPI_RA_ADDR_H, &wValueH, WDC_MODE_16);

		WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, BAR2, HPI_R_SD_ADDR_L, &p[i*2], WDC_MODE_16);
		WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, BAR2, HPI_R_SD_ADDR_H, &p[i*2+1], WDC_MODE_16);
	} 
	
	/* auto*****************************************************************
	
	WORD wValueL	=	(MONITOR_CHANNEL_2_BASE) & MONITOR_CHANNEL_ADDR_MASK;
	WORD wValueH	=	(MONITOR_CHANNEL_2_BASE) >> MONITOR_CHANNEL_ADDR_SHF;

	for (i=0;i<nReadTime;i++)
	{
		WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, BAR2, HPI_R_CD_ADDR_L, &p[i*2], WDC_MODE_16);
		WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, BAR2, HPI_R_CD_ADDR_H, &p[i*2+1], WDC_MODE_16);
	}  
	*/

	/***************************************************************************************/

	/************************** READ DATA VIA DMA FROM FPGA 3 ****************************

	int nData = MONITOR_DATA_SIZE/2; // in word 
	int j;
	unsigned int	 PCI_SAMPLE_DATA_Addr = PCI_SAMPLE_BASE;
	for (j=0;j<nData;j++)
	{
		 WDC_DIAG_ReadWriteAddr(hDev, WDC_READ, BAR2, PCI_SAMPLE_DATA_Addr, &p[j], WDC_MODE_16);
		PCI_SAMPLE_DATA_Addr=PCI_SAMPLE_DATA_Addr+2;
	}*/

}

_declspec (dllexport) DWORD DLLCALLCONV Plx_PciReadCfg16(WDC_DEVICE_HANDLE hDev, DWORD dwOffset, WORD *val)
{
	return WDC_PciReadCfg16(hDev, dwOffset, val);
}